-- Phantom Ball Auto Parry + Spam [FINAL v5.4]

local tick       = tick
local math_clamp = math.clamp
local typeof     = typeof

if getgenv().__na_aex_conn then
    getgenv().__na_aex_conn:Disconnect()
    getgenv().__na_aex_conn = nil
end
if getgenv().__na_aex then return end
getgenv().__na_aex = true

if game.GameId ~= 4538598064 then return end

local Plrs    = game:GetService("Players")
local RS      = game:GetService("RunService")
local RSrv    = game:GetService("ReplicatedStorage")
local WS      = workspace
local UIS     = game:GetService("UserInputService")
local Stats   = game:GetService("Stats")
local CoreGui = game:GetService("CoreGui")

local Config = {
    manualPingOffset     = 0.045,
    pingSmooth           = 0.15,
    pingMultiplier       = 1.05,
    thresholdMin         = 0.05,
    thresholdMax         = 0.55,
    thresholdBase        = 0.12,
    processResetInterval = 0.4,
    parryFireCD          = 0.05,

    ballResetThresh  = 50,
    ballResetLockout = 0.6,

    spamInterval    = 0.00167,
    spamCapPerFrame = 10,

    clashHistorySize  = 8,
    clashTimeWindow   = 0.45,
    clashMinDist      = 35,
    clashCriticalDist = 12,
    clashDecayTime    = 1.2,
    clashMinHistory   = 4,
    clashCooldown     = 1.5,
    clashRadMult      = 1.5,

    activationDistanceOffset = 7,
    auraUpdateRate           = 0.015,
}

if getgenv().__deltaV3_autoParryOn  == nil then getgenv().__deltaV3_autoParryOn  = true    end
if getgenv().__deltaV3_autoClashOn  == nil then getgenv().__deltaV3_autoClashOn  = true    end
if getgenv().__deltaV3_auraOn       == nil then getgenv().__deltaV3_auraOn       = true    end
if getgenv().__deltaV3_spamInterval == nil then getgenv().__deltaV3_spamInterval = 0.00167 end
if getgenv().__deltaV3_spamKeyMode  == nil then getgenv().__deltaV3_spamKeyMode  = "hold"  end

-- ============================================================
-- NETWORK
-- ============================================================
local Net = nil
local Def = nil

pcall(function() Net = require(RSrv.TS.Network.Network).Network end)
pcall(function() Def = require(RSrv.TS.Abilities.DeflectAbility).DeflectAbility end)

local TS_Folder   = RSrv:WaitForChild("TS", 10)
local NetRemotes  = TS_Folder and TS_Folder:WaitForChild("GeneratedNetworkRemotes", 10)
local parryRemote = NetRemotes and NetRemotes:FindFirstChild("RE_4.6848415795802784e+76")

local ballSyncFolder = RSrv:WaitForChild("Remotes", 5)
local ballSyncRemote = ballSyncFolder and ballSyncFolder:FindFirstChild("BallSyncData")

local PNotif = RSrv:WaitForChild("PromptNotification")
task.spawn(function()
    PNotif:Fire("Auto Parry FINAL v5.4 ✅ | PC + Mobile", true)
end)

local spamOn      = false
local clashSpamOn = false

pcall(function()
    local orig
    orig = hookfunction(Def.IsAvailable, function(self, ...)
        if spamOn or clashSpamOn then return true end
        return orig(self, ...)
    end)
end)

pcall(function()
    local oSend
    oSend = hookfunction(Net.CSendEvent, function(self, router, evt, ...)
        if router == 46848415795802784000000000000000000000000000000000000000000000000000000000000 then
            return oSend(self, router, 29338138590583890000000000000000000000000000000000000000000000000000000000000, ...)
        end
        return oSend(self, router, evt, ...)
    end)
end)

local function sendParry()
    if parryRemote then
        pcall(function()
            parryRemote:FireServer(2.933813859058389e+76)
        end)
        return
    end
    if Net then
        Net:CSendEvent(
            46848415795802784000000000000000000000000000000000000000000000000000000000000,
            6846744283873508500000000000000000000000000000000000000000000000000000000000
        )
    end
end

-- ============================================================
-- GAME INFO
-- ============================================================
local gi, br

do
    local ok, mod = pcall(function()
        return require(RSrv:WaitForChild("TS"):WaitForChild("GameInfo"))
    end)
    if ok and mod and mod.GameInfo then gi = mod.GameInfo end
end

do
    local ok, mod = pcall(function()
        return require(RSrv:WaitForChild("TS"):WaitForChild("BallReplicator"):WaitForChild("BallReplicator"))
    end)
    if ok and mod and mod.BallReplicator then br = mod.BallReplicator end
end

local lp = Plrs.LocalPlayer

-- ============================================================
-- CACHE
-- ============================================================
local Cache = { Character = nil, RootPart = nil, Ball = nil }

local function trySetBall(obj)
    if obj.Name == "GameBall" then Cache.Ball = obj end
end

WS.ChildAdded:Connect(trySetBall)
WS.ChildRemoved:Connect(function(obj)
    if Cache.Ball == obj then Cache.Ball = nil end
end)

for _, v in ipairs(WS:GetChildren()) do
    if v.Name == "GameBall" then Cache.Ball = v; break end
end

local function setupCharacter(ch)
    if not ch then return end
    Cache.Character = ch
    Cache.RootPart  = ch:WaitForChild("HumanoidRootPart", 10)
end

lp.CharacterAdded:Connect(setupCharacter)
setupCharacter(lp.Character)

local function getBall()
    if Cache.Ball and Cache.Ball.Parent then return Cache.Ball end
    if gi and gi.BallModel and gi.BallModel.Parent then
        Cache.Ball = gi.BallModel
        return Cache.Ball
    end
    Cache.Ball = WS:FindFirstChild("GameBall", true)
    return Cache.Ball
end

local function tgtOnFallback()
    local ch = lp.Character
    if ch and ch:FindFirstChild("Highlight") then return true end
    if WS:GetAttribute("GameBallTarget") == lp.UserId then return true end
    if br and br.syncData and br.syncData.HighlightTargetPlayerID == lp.UserId then return true end
    return false
end

-- ============================================================
-- BALL SYNC
-- ============================================================
local BallSync = {
    RealPosition = Vector3.zero,
    Speed        = 0,
    TargetID     = -999,
}

if ballSyncRemote then
    ballSyncRemote.OnClientEvent:Connect(function(data)
        if typeof(data) ~= "table" then return end
        if data.RealPosition then
            BallSync.RealPosition = data.RealPosition
        end
        if typeof(data.Speed) == "number" then
            BallSync.Speed = data.Speed
        elseif type(data.Speed) == "table" and data.Speed.Magnitude then
            BallSync.Speed = data.Speed.Magnitude
        end
        if data.TargetPlayerID then
            BallSync.TargetID = data.TargetPlayerID
        end
    end)
end

-- ============================================================
-- PING
-- ============================================================
local smoothedPing = 0.05

local function updatePing()
    local ok, raw = pcall(function()
        return Stats.Network.ServerStatsItem["Data Ping"]:GetValue() / 1000
    end)
    if ok and type(raw) == "number" and raw > 0 then
        smoothedPing = smoothedPing * (1 - Config.pingSmooth) + raw * Config.pingSmooth
    end
end

-- ============================================================
-- CLASH DETECTION
-- ============================================================
local ClashState = {
    Active             = false,
    LastActivationTime = 0,
    LastClashTime      = 0,
    CurrentOpponent    = nil,
}

local TargetHistory = {}
local lastTarget    = nil

local function resetClash()
    ClashState.Active = false
    clashSpamOn       = false
    TargetHistory     = {}
    lastTarget        = nil
end

local function updateClashDetection(newTargetID, ballPos, hrpPos)
    if newTargetID == lastTarget then return end
    lastTarget = newTargetID

    if not Cache.RootPart then return end

    local dist = (hrpPos - ballPos).Magnitude
    local now  = tick()

    table.insert(TargetHistory, 1, { id = newTargetID, t = now })
    if #TargetHistory > Config.clashHistorySize then
        table.remove(TargetHistory)
    end

    if (now - ClashState.LastClashTime) < Config.clashCooldown then return end

    if #TargetHistory >= Config.clashMinHistory then
        local timeGap       = TargetHistory[1].t - TargetHistory[Config.clashMinHistory].t
        local isAlternating = true
        for i = 1, Config.clashMinHistory do
            local expectedMe = (i % 2 == 1)
            local isMe       = (TargetHistory[i].id == lp.UserId)
            if expectedMe ~= isMe then isAlternating = false; break end
        end

        if isAlternating and timeGap < Config.clashTimeWindow and dist < Config.clashMinDist then
            ClashState.Active             = true
            ClashState.LastActivationTime = now
            ClashState.LastClashTime      = now
            ClashState.CurrentOpponent    = TargetHistory[2].id
        end
    end

    if newTargetID == lp.UserId and dist < Config.clashCriticalDist then
        ClashState.Active             = true
        ClashState.LastActivationTime = now
        ClashState.LastClashTime      = now
    end
end

-- ============================================================
-- SPAM
-- ============================================================
local lastSpamFire = 0
local toggleButton

local function updateGUI()
    if not toggleButton then return end
    toggleButton.Text             = spamOn and "SPAM ON" or "SPAM OFF"
    toggleButton.BackgroundColor3 = spamOn
        and Color3.fromRGB(50, 220, 50)
        or  Color3.fromRGB(220, 50, 50)
end

local function setSpam(v)
    if spamOn == v then return end
    spamOn       = v
    lastSpamFire = tick()
    -- ── expõe o estado atual para a GUI poder ler no toggle ──
    getgenv().__deltaV3_spamActive = v
    updateGUI()
end

getgenv().__deltaV3_setSpam     = function(v) setSpam(v) end
getgenv().__deltaV3_setSpamMode = function(mode) getgenv().__deltaV3_spamKeyMode = mode end

-- ============================================================
-- KEYBIND
-- ============================================================
local spamKeyConns = {}

local function clearSpamKeyConns()
    for _, c in ipairs(spamKeyConns) do c:Disconnect() end
    spamKeyConns = {}
end

local function bindSpamKey(label)
    clearSpamKeyConns()

    local function onPress()
        local mode = getgenv().__deltaV3_spamKeyMode or "hold"
        if mode == "toggle" then
            setSpam(not spamOn)
        else
            setSpam(true)
        end
    end

    local function onRelease()
        if (getgenv().__deltaV3_spamKeyMode or "hold") == "hold" then
            setSpam(false)
        end
    end

    if label == "MB1" or label == "MB2" then
        local uType = label == "MB1"
            and Enum.UserInputType.MouseButton1
            or  Enum.UserInputType.MouseButton2

        table.insert(spamKeyConns, UIS.InputBegan:Connect(function(inp, gpe)
            if gpe then return end
            if inp.UserInputType == uType then onPress() end
        end))
        table.insert(spamKeyConns, UIS.InputEnded:Connect(function(inp)
            if inp.UserInputType == uType then onRelease() end
        end))
    else
        local keyMap = {
            ["1"] = Enum.KeyCode.One,
            F = Enum.KeyCode.F, G = Enum.KeyCode.G,
            Q = Enum.KeyCode.Q, E = Enum.KeyCode.E,
        }
        local kc = keyMap[label]
        if not kc then return end

        table.insert(spamKeyConns, UIS.InputBegan:Connect(function(inp, gpe)
            if gpe then return end
            if inp.KeyCode == kc then onPress() end
        end))
        table.insert(spamKeyConns, UIS.InputEnded:Connect(function(inp)
            if inp.KeyCode == kc then onRelease() end
        end))
    end
end

bindSpamKey("1")
getgenv().__deltaV3_bindSpamKey = bindSpamKey

-- ============================================================
-- GUI DE SPAM
-- ============================================================
task.spawn(function()
    local old = CoreGui:FindFirstChild("ParrySpamToggleGui")
    if old then old:Destroy() end

    local screenGui = Instance.new("ScreenGui")
    screenGui.Name           = "ParrySpamToggleGui"
    screenGui.ResetOnSpawn   = false
    screenGui.IgnoreGuiInset = true
    screenGui.Enabled        = false
    screenGui.Parent         = CoreGui

    local mainFrame = Instance.new("Frame")
    mainFrame.Size             = UDim2.new(0, 120, 0, 95)
    mainFrame.Position         = UDim2.new(1, -130, 0.5, -47)
    mainFrame.BackgroundColor3 = Color3.fromRGB(18, 18, 30)
    mainFrame.BorderSizePixel  = 0
    mainFrame.Parent           = screenGui
    Instance.new("UICorner", mainFrame).CornerRadius = UDim.new(0, 14)

    local stroke     = Instance.new("UIStroke")
    stroke.Color     = Color3.fromRGB(70, 90, 200)
    stroke.Thickness = 1.5
    stroke.Parent    = mainFrame

    local titleBar = Instance.new("Frame")
    titleBar.Size             = UDim2.new(1, 0, 0, 24)
    titleBar.BackgroundColor3 = Color3.fromRGB(30, 30, 55)
    titleBar.BorderSizePixel  = 0
    titleBar.Parent           = mainFrame
    Instance.new("UICorner", titleBar).CornerRadius = UDim.new(0, 14)

    local titleLabel = Instance.new("TextLabel")
    titleLabel.Size                   = UDim2.new(1, -6, 1, 0)
    titleLabel.Position               = UDim2.new(0, 6, 0, 0)
    titleLabel.BackgroundTransparency = 1
    titleLabel.Text                   = "FINAL v5.4"
    titleLabel.TextColor3             = Color3.fromRGB(180, 195, 255)
    titleLabel.TextScaled             = true
    titleLabel.Font                   = Enum.Font.GothamBold
    titleLabel.Parent                 = titleBar

    toggleButton = Instance.new("TextButton")
    toggleButton.Size             = UDim2.new(0.85, 0, 0, 52)
    toggleButton.Position         = UDim2.new(0.075, 0, 0, 30)
    toggleButton.BackgroundColor3 = Color3.fromRGB(220, 50, 50)
    toggleButton.BorderSizePixel  = 0
    toggleButton.Text             = "SPAM OFF"
    toggleButton.TextColor3       = Color3.fromRGB(255, 255, 255)
    toggleButton.TextScaled       = true
    toggleButton.Font             = Enum.Font.GothamBold
    toggleButton.Parent           = mainFrame
    Instance.new("UICorner", toggleButton).CornerRadius = UDim.new(0, 10)

    local dragging, dragStart, startPos = false, nil, nil

    local function updateDrag(input)
        if not dragStart or not startPos then return end
        local delta  = input.Position - dragStart
        local vpSize = WS.CurrentCamera.ViewportSize
        local fSize  = mainFrame.AbsoluteSize
        mainFrame.Position = UDim2.new(
            0, math_clamp(startPos.X.Offset + delta.X, 0, vpSize.X - fSize.X),
            0, math_clamp(startPos.Y.Offset + delta.Y, 0, vpSize.Y - fSize.Y)
        )
    end

    titleBar.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1
        or input.UserInputType == Enum.UserInputType.Touch then
            dragging  = true
            dragStart = input.Position
            startPos  = mainFrame.Position
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then dragging = false end
            end)
        end
    end)

    titleBar.InputChanged:Connect(function(input)
        if dragging and (
            input.UserInputType == Enum.UserInputType.MouseMovement or
            input.UserInputType == Enum.UserInputType.Touch
        ) then updateDrag(input) end
    end)

    UIS.InputChanged:Connect(function(input)
        if dragging and input.UserInputType == Enum.UserInputType.Touch then
            updateDrag(input)
        end
    end)

    toggleButton.Activated:Connect(function() setSpam(not spamOn) end)
    updateGUI()
end)

-- ============================================================
-- AURA VISUAL
-- ============================================================
local OUTER_TRANSPARENCY = 0.18
local INNER_TRANSPARENCY = 0.9
local AREA_COLOR         = Color3.fromRGB(255, 255, 255)
local SPAM_COLOR         = Color3.fromRGB(255, 50,  50)
local CLASH_COLOR        = Color3.fromRGB(255, 200, 50)

local function createAuraPart(name)
    local p = Instance.new("Part")
    p.Name         = name
    p.Shape        = Enum.PartType.Ball
    p.Material     = Enum.Material.ForceField
    p.Anchored     = true
    p.CanCollide   = false
    p.CastShadow   = false
    p.Transparency = 1
    p.Color        = AREA_COLOR
    p.Parent       = WS
    return p
end

local auraOuter        = createAuraPart("DeltaAuraOuter")
local auraInner        = createAuraPart("DeltaAuraInner")
local lastVisualUpdate = 0

local auraConn = RS.RenderStepped:Connect(function()
    local now = tick()
    if (now - lastVisualUpdate) < Config.auraUpdateRate then return end
    lastVisualUpdate = now

    local hrp = Cache.RootPart
    if not getgenv().__deltaV3_auraOn or not hrp or not hrp.Parent then
        auraOuter.Transparency = 1
        auraInner.Transparency = 1
        return
    end

    local speed   = BallSync.Speed > 0 and BallSync.Speed or 45
    local baseRad = math_clamp(speed * 0.32 + 6, 9, 90) + 10 + Config.activationDistanceOffset
    local rad     = ClashState.Active and (baseRad * Config.clashRadMult) or baseRad
    local sz      = Vector3.new(rad * 2, rad * 2, rad * 2)
    local szIn    = Vector3.new((rad-0.5)*2, (rad-0.5)*2, (rad-0.5)*2)

    auraOuter.CFrame = hrp.CFrame
    auraInner.CFrame = hrp.CFrame
    auraOuter.Size   = sz
    auraInner.Size   = szIn

    local targetColor = clashSpamOn and CLASH_COLOR
                     or spamOn      and SPAM_COLOR
                     or AREA_COLOR

    auraOuter.Color        = auraOuter.Color:Lerp(targetColor, 0.3)
    auraOuter.Transparency = OUTER_TRANSPARENCY
    auraInner.Transparency = INNER_TRANSPARENCY
end)

-- ============================================================
-- HEARTBEAT PRINCIPAL
-- ============================================================
local ballProcessed    = false
local lastProcessReset = 0

local function bind(ch)
    setupCharacter(ch)

    local hrp         = ch:WaitForChild("HumanoidRootPart", 10)
    local lastBallPos = nil
    local ballResetAt = 0
    local lastFire    = 0
    local pingTimer   = 0

    local connection
    connection = RS.Heartbeat:Connect(function(dt)
        if not (ch and ch.Parent and hrp and hrp.Parent) then
            connection:Disconnect()
            return
        end

        local now          = tick()
        local autoParryOn  = getgenv().__deltaV3_autoParryOn
        local autoClashOn  = getgenv().__deltaV3_autoClashOn
        local spamInterval = getgenv().__deltaV3_spamInterval or Config.spamInterval

        clashSpamOn = (autoClashOn and ClashState.Active) and true or false

        -- ── SPAM ──
        if spamOn or clashSpamOn then
            local fired = 0
            while (now - lastSpamFire) >= spamInterval and fired < Config.spamCapPerFrame do
                sendParry()
                lastSpamFire = lastSpamFire + spamInterval
                fired        = fired + 1
            end
            if (now - lastSpamFire) > spamInterval * Config.spamCapPerFrame then
                lastSpamFire = now
            end
            return
        else
            lastSpamFire = now
        end

        if not autoParryOn then return end

        pingTimer = pingTimer + dt
        if pingTimer >= 2 then
            pingTimer = 0
            task.spawn(updatePing)
        end

        if ballProcessed and (now - lastProcessReset) >= Config.processResetInterval then
            ballProcessed = false
        end

        if ClashState.Active and (now - ClashState.LastActivationTime) > Config.clashDecayTime then
            resetClash()
        end

        local b = getBall()
        if not (b and b.Parent) then return end

        local bp = b.Position

        -- bola nova
        if not lastBallPos then
            lastBallPos = bp
            resetClash()
            return
        end

        -- teleporte/reset
        if (bp - lastBallPos).Magnitude > Config.ballResetThresh then
            ballProcessed    = true
            lastProcessReset = now
            ballResetAt      = now
            lastBallPos      = bp
            resetClash()
            return
        end
        lastBallPos = bp

        if (now - ballResetAt) < Config.ballResetLockout then return end

        local hrpPos = hrp.Position

        local currentTarget = BallSync.TargetID ~= -999 and BallSync.TargetID
                           or WS:GetAttribute("GameBallTarget")
        if currentTarget then
            updateClashDetection(currentTarget, bp, hrpPos)
        end

        -- ── AUTO PARRY (lógica Phantom) ──
        local ballPos = (BallSync.RealPosition ~= Vector3.zero)
            and BallSync.RealPosition or bp

        local speed       = BallSync.Speed > 0 and BallSync.Speed
                         or b.AssemblyLinearVelocity.Magnitude

        local distance    = (hrpPos - ballPos).Magnitude
        local timeToReach = distance / math.max(speed, 1)
        local threshold   = math_clamp(
            Config.thresholdBase
            + smoothedPing * Config.pingMultiplier
            + Config.manualPingOffset,
            Config.thresholdMin,
            Config.thresholdMax
        )

        local isTarget = (BallSync.TargetID == lp.UserId)
                      or (BallSync.TargetID == -999 and tgtOnFallback())

        if isTarget
            and timeToReach <= threshold
            and not ballProcessed
            and (now - lastFire) >= Config.parryFireCD
        then
            sendParry()
            lastFire         = now
            ballProcessed    = true
            lastProcessReset = now
        end
    end)

    getgenv().__na_aex_conn = connection

    ch.AncestryChanged:Connect(function(_, p)
        if not p then
            connection:Disconnect()
            setSpam(false)
            resetClash()
            lastSpamFire           = 0
            lastBallPos            = nil
            ballProcessed          = false
            auraOuter.Transparency = 1
            auraInner.Transparency = 1
            updateGUI()
        end
    end)
end

lp.CharacterAdded:Connect(bind)
if lp.Character then bind(lp.Character) end

CoreGui.ChildRemoved:Connect(function(c)
    if c.Name == "DeltaV3Gui" then
        if auraConn then auraConn:Disconnect() end
        pcall(function() auraOuter:Destroy() end)
        pcall(function() auraInner:Destroy() end)
        clearSpamKeyConns()
        getgenv().__na_aex = nil
        if getgenv().__na_aex_conn then
            getgenv().__na_aex_conn:Disconnect()
            getgenv().__na_aex_conn = nil
        end
    end
end)
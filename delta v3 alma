-- ============================================================
-- Blade Ball Auto Parry + Spam [MERGED v4.0] — ALMA
-- Mesclagem de Delta v3.2 + Beta v2
-- 1 único Heartbeat | Clash mais preciso e raro
-- ============================================================

local tick       = tick
local math_clamp = math.clamp
local typeof     = typeof

-- Cleanup de execução anterior
if getgenv().__na_aex_conn then
    getgenv().__na_aex_conn:Disconnect()
    getgenv().__na_aex_conn = nil
end
if getgenv().__na_aex then return end
getgenv().__na_aex = true

if game.GameId ~= 4538598064 then return end

-- ============================================================
-- SERVICES
-- ============================================================
local Plrs    = game:GetService("Players")
local RS      = game:GetService("RunService")
local RSrv    = game:GetService("ReplicatedStorage")
local WS      = workspace
local UIS     = game:GetService("UserInputService")
local Stats   = game:GetService("Stats")
local CoreGui = game:GetService("CoreGui")

-- ============================================================
-- CONFIG
-- ============================================================
local Config = {
    -- Parry timing
    parryCDMin    = 0.05,
    parryCDMax    = 0.3,
    parryCDFactor = 0.5,
    clashCDFactor = 0.1,

    -- Velocidade / raio
    velSmooth     = 0.05,
    minRadius     = 9,
    maxRadius     = 90,
    radiusWin     = 0.32,
    radiusOff     = 6,
    radiusPre     = 10,
    minSpeed      = 5,
    maxImpactTime = 0.35,

    -- Reset de bola
    ballResetThresh  = 50,
    ballResetLockout = 0.6,

    -- Reset de processamento
    processResetNormal = 0.3,
    processResetClash  = 0.05,

    -- Raio clash
    clashRadMult = 1.5,

    -- Spam
    spamInterval    = 0.00167,   -- ~600 CPS
    spamCapPerFrame = 10,

    -- Ping
    pingSmooth     = 0.15,
    pingMultiplier = 1.1,
    pingOffset     = 0.02,
    pingMin        = 0.02,
    pingMax        = 0.25,

    -- Clash detection — mais raro e preciso
    clashHistorySize  = 8,    -- mais histórico antes de confirmar (era 6)
    clashTimeWindow   = 0.45, -- janela mais apertada (era 0.6)
    clashMinDist      = 35,   -- distância menor exigida (era 40)
    clashCriticalDist = 12,   -- muito mais perto pra ativar via distância crítica (era 20)
    clashDecayTime    = 1.2,  -- fica ativo mais tempo depois de confirmado (era 0.5)
    clashMinHistory   = 4,    -- exige 4 entradas pro padrão alternado (era 3)
    clashCooldown     = 1.5,  -- tempo mínimo entre ativações de clash
}

-- ============================================================
-- REDE COM O SCRIPT CONTROLE (getgenv)
-- ============================================================
if getgenv().__deltaV3_autoParryOn  == nil then getgenv().__deltaV3_autoParryOn  = true  end
if getgenv().__deltaV3_autoClashOn  == nil then getgenv().__deltaV3_autoClashOn  = true  end
if getgenv().__deltaV3_auraOn       == nil then getgenv().__deltaV3_auraOn       = false end
if getgenv().__deltaV3_spamInterval == nil then getgenv().__deltaV3_spamInterval = 0.00167 end

-- ============================================================
-- NETWORK
-- ============================================================
local Net    = require(RSrv.TS.Network.Network).Network
local Def    = require(RSrv.TS.Abilities.DeflectAbility).DeflectAbility
local PNotif = RSrv:WaitForChild("PromptNotification")

task.spawn(function()
    PNotif:Fire("Auto Parry MERGED v4.0 ✅ | Clash Preciso", true)
end)

local spamOn      = false
local clashSpamOn = false

local originalIsAvailable
originalIsAvailable = hookfunction(Def.IsAvailable, function(self, ...)
    if spamOn or clashSpamOn then return true end
    return originalIsAvailable(self, ...)
end)

local oSend
oSend = hookfunction(Net.CSendEvent, function(self, router, evt, ...)
    if router == 46848415795802784000000000000000000000000000000000000000000000000000000000000 then
        return oSend(self, router, 29338138590583890000000000000000000000000000000000000000000000000000000000000, ...)
    end
    return oSend(self, router, evt, ...)
end)

local function sendParry()
    if not Net then return end
    Net:CSendEvent(
        46848415795802784000000000000000000000000000000000000000000000000000000000000,
        6846744283873508500000000000000000000000000000000000000000000000000000000000
    )
end

-- ============================================================
-- GAME INFO
-- ============================================================
local gi, br

do
    local ok, mod = pcall(function()
        return require(RSrv:WaitForChild("TS"):WaitForChild("GameInfo"))
    end)
    if ok and mod and mod.GameInfo then gi = mod.GameInfo end
end

do
    local ok, mod = pcall(function()
        return require(
            RSrv:WaitForChild("TS")
                :WaitForChild("BallReplicator")
                :WaitForChild("BallReplicator")
        )
    end)
    if ok and mod and mod.BallReplicator then br = mod.BallReplicator end
end

local lp = Plrs.LocalPlayer

-- ============================================================
-- CACHE
-- ============================================================
local Cache = { Character = nil, RootPart = nil, Ball = nil }

local function trySetBall(obj)
    if obj.Name == "GameBall" then Cache.Ball = obj end
end

WS.ChildAdded:Connect(trySetBall)
WS.ChildRemoved:Connect(function(obj)
    if Cache.Ball == obj then Cache.Ball = nil end
end)

for _, v in ipairs(WS:GetChildren()) do
    if v.Name == "GameBall" then Cache.Ball = v; break end
end

local function setupCharacter(ch)
    if not ch then return end
    Cache.Character = ch
    Cache.RootPart  = ch:WaitForChild("HumanoidRootPart", 10)
end

lp.CharacterAdded:Connect(setupCharacter)
setupCharacter(lp.Character)

local function getBall()
    if Cache.Ball and Cache.Ball.Parent then return Cache.Ball end
    if gi and gi.BallModel and gi.BallModel.Parent then
        Cache.Ball = gi.BallModel
        return Cache.Ball
    end
    Cache.Ball = WS:FindFirstChild("GameBall", true)
    return Cache.Ball
end

local function tgtOn()
    local ch = lp.Character
    if ch and ch:FindFirstChild("Highlight") then return true end
    if WS:GetAttribute("GameBallTarget") == lp.UserId then return true end
    if br and br.syncData and br.syncData.HighlightTargetPlayerID == lp.UserId then return true end
    return false
end

-- ============================================================
-- PING
-- ============================================================
local smoothedPing = 0.05

local function updatePing()
    local ok, raw = pcall(function()
        return Stats.Network.ServerStatsItem["Data Ping"]:GetValue() / 1000
    end)
    if ok and type(raw) == "number" and raw > 0 then
        smoothedPing = smoothedPing * (1 - Config.pingSmooth) + raw * Config.pingSmooth
    end
end

local function getPingCompensation()
    return math_clamp(
        smoothedPing * Config.pingMultiplier + Config.pingOffset,
        Config.pingMin, Config.pingMax
    )
end

-- ============================================================
-- STATE MACHINE
-- ============================================================
local State = { current = "normal", lastTransition = 0 }

local function setState(s)
    if State.current == s then return end
    State.current        = s
    State.lastTransition = tick()
end

-- ============================================================
-- REENTRÂNCIA
-- ============================================================
local ballProcessed    = false
local lastProcessReset = 0

-- ============================================================
-- CLASH DETECTION — mais raro e preciso
-- ============================================================
local ClashState = {
    Active             = false,
    LastActivationTime = 0,
    LastClashTime      = 0,  -- cooldown entre ativações
    CurrentOpponent    = nil,
}

local TargetHistory = {}
local lastTarget    = nil

local function updateClashDetection(newTargetID, ballPos, ballVel, hrpPos)
    if newTargetID == lastTarget then return end

    -- Reset de processo quando o alvo muda (do v3.2)
    if lastTarget ~= nil then
        ballProcessed    = false
        lastProcessReset = 0
    end

    lastTarget = newTargetID

    if not Cache.RootPart then return end

    local dist = (hrpPos - ballPos).Magnitude
    local now  = tick()

    table.insert(TargetHistory, 1, { id = newTargetID, t = now })
    if #TargetHistory > Config.clashHistorySize then
        table.remove(TargetHistory)
    end

    -- Cooldown entre ativações de clash
    if (now - ClashState.LastClashTime) < Config.clashCooldown then return end

    -- Padrão alternado: exige clashMinHistory entradas (4 por padrão)
    if #TargetHistory >= Config.clashMinHistory then
        local timeGap = TargetHistory[1].t - TargetHistory[Config.clashMinHistory].t

        -- Verifica alternância: posições ímpares = eu, pares = oponente
        local isAlternating = true
        for i = 1, Config.clashMinHistory do
            local expectedMe = (i % 2 == 1)
            local isMe       = (TargetHistory[i].id == lp.UserId)
            if expectedMe ~= isMe then
                isAlternating = false
                break
            end
        end

        if isAlternating
            and timeGap < Config.clashTimeWindow
            and dist   < Config.clashMinDist
        then
            ClashState.Active             = true
            ClashState.LastActivationTime = now
            ClashState.LastClashTime      = now
            ClashState.CurrentOpponent    = TargetHistory[2].id
            setState("clash")
        end
    end

    -- Distância crítica: exige que a bola esteja SE APROXIMANDO de mim
    if newTargetID == lp.UserId
        and dist < Config.clashCriticalDist
        and ballVel ~= nil
        and ballVel:Dot(hrpPos - ballPos) > 0  -- bola vindo em direção a mim
    then
        ClashState.Active             = true
        ClashState.LastActivationTime = now
        ClashState.LastClashTime      = now
        setState("clash")
    end
end

-- ============================================================
-- SPAM STATE
-- ============================================================
local lastSpamFire = 0
local toggleButton

local function updateGUI()
    if not toggleButton then return end
    toggleButton.Text             = spamOn and "SPAM ON" or "SPAM OFF"
    toggleButton.BackgroundColor3 = spamOn
        and Color3.fromRGB(50, 220, 50)
        or  Color3.fromRGB(220, 50, 50)
end

local function setSpam(v)
    if spamOn == v then return end
    spamOn       = v
    lastSpamFire = tick()
    setState(v and "spam" or "normal")
    updateGUI()
end

getgenv().__deltaV3_setSpam = function(v) setSpam(v) end

-- ============================================================
-- GUI
-- ============================================================
task.spawn(function()
    local old = CoreGui:FindFirstChild("ParrySpamToggleGui")
    if old then old:Destroy() end

    local screenGui = Instance.new("ScreenGui")
    screenGui.Name           = "ParrySpamToggleGui"
    screenGui.ResetOnSpawn   = false
    screenGui.IgnoreGuiInset = true
    screenGui.Enabled        = false
    screenGui.Parent         = CoreGui

    local mainFrame = Instance.new("Frame")
    mainFrame.Size             = UDim2.new(0, 120, 0, 95)
    mainFrame.Position         = UDim2.new(1, -130, 0.5, -47)
    mainFrame.BackgroundColor3 = Color3.fromRGB(18, 18, 30)
    mainFrame.BorderSizePixel  = 0
    mainFrame.Parent           = screenGui
    Instance.new("UICorner", mainFrame).CornerRadius = UDim.new(0, 14)

    local stroke     = Instance.new("UIStroke")
    stroke.Color     = Color3.fromRGB(70, 90, 200)
    stroke.Thickness = 1.5
    stroke.Parent    = mainFrame

    local titleBar = Instance.new("Frame")
    titleBar.Size             = UDim2.new(1, 0, 0, 24)
    titleBar.BackgroundColor3 = Color3.fromRGB(30, 30, 55)
    titleBar.BorderSizePixel  = 0
    titleBar.Parent           = mainFrame
    Instance.new("UICorner", titleBar).CornerRadius = UDim.new(0, 14)

    local titleLabel = Instance.new("TextLabel")
    titleLabel.Size                   = UDim2.new(1, -6, 1, 0)
    titleLabel.Position               = UDim2.new(0, 6, 0, 0)
    titleLabel.BackgroundTransparency = 1
    titleLabel.Text                   = "SPAM v4.0"
    titleLabel.TextColor3             = Color3.fromRGB(180, 195, 255)
    titleLabel.TextScaled             = true
    titleLabel.Font                   = Enum.Font.GothamBold
    titleLabel.Parent                 = titleBar

    toggleButton = Instance.new("TextButton")
    toggleButton.Size             = UDim2.new(0.85, 0, 0, 52)
    toggleButton.Position         = UDim2.new(0.075, 0, 0, 30)
    toggleButton.BackgroundColor3 = Color3.fromRGB(220, 50, 50)
    toggleButton.BorderSizePixel  = 0
    toggleButton.Text             = "SPAM OFF"
    toggleButton.TextColor3       = Color3.fromRGB(255, 255, 255)
    toggleButton.TextScaled       = true
    toggleButton.Font             = Enum.Font.GothamBold
    toggleButton.Parent           = mainFrame
    Instance.new("UICorner", toggleButton).CornerRadius = UDim.new(0, 10)

    local dragging, dragStart, startPos = false, nil, nil

    local function updateDrag(input)
        if not dragStart or not startPos then return end
        local delta  = input.Position - dragStart
        local vpSize = WS.CurrentCamera.ViewportSize
        local fSize  = mainFrame.AbsoluteSize
        mainFrame.Position = UDim2.new(
            0, math_clamp(startPos.X.Offset + delta.X, 0, vpSize.X - fSize.X),
            0, math_clamp(startPos.Y.Offset + delta.Y, 0, vpSize.Y - fSize.Y)
        )
    end

    titleBar.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1
        or input.UserInputType == Enum.UserInputType.Touch then
            dragging  = true
            dragStart = input.Position
            startPos  = mainFrame.Position
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                end
            end)
        end
    end)

    titleBar.InputChanged:Connect(function(input)
        if dragging and (
            input.UserInputType == Enum.UserInputType.MouseMovement or
            input.UserInputType == Enum.UserInputType.Touch
        ) then updateDrag(input) end
    end)

    UIS.InputChanged:Connect(function(input)
        if dragging and input.UserInputType == Enum.UserInputType.Touch then
            updateDrag(input)
        end
    end)

    -- Tecla X (do v2) também funciona aqui
    UIS.InputBegan:Connect(function(inp, gpe)
        if gpe then return end
        if inp.KeyCode == Enum.KeyCode.X then setSpam(not spamOn) end
    end)

    toggleButton.Activated:Connect(function() setSpam(not spamOn) end)
    updateGUI()
end)

-- ============================================================
-- AURA VISUAL (RenderStepped — correto, é só visual)
-- ============================================================
local OUTER_TRANSPARENCY       = 0.18
local INNER_TRANSPARENCY       = 0.9
local AREA_COLOR               = Color3.fromRGB(255, 255, 255)
local SPAM_COLOR               = Color3.fromRGB(255, 50,  50)
local CLASH_COLOR              = Color3.fromRGB(255, 200, 50)  -- cor especial no clash
local activationDistanceOffset = 7
local lastVisualUpdate         = 0

local function createAuraPart(name)
    local p = Instance.new("Part")
    p.Name         = name
    p.Shape        = Enum.PartType.Ball
    p.Material     = Enum.Material.ForceField
    p.Anchored     = true
    p.CanCollide   = false
    p.CastShadow   = false
    p.Transparency = 1
    p.Color        = AREA_COLOR
    p.Parent       = workspace
    return p
end

local auraOuter = createAuraPart("DeltaAuraOuter")
local auraInner = createAuraPart("DeltaAuraInner")

local auraConn = RS.RenderStepped:Connect(function()
    local now = tick()
    if (now - lastVisualUpdate) < 0.015 then return end
    lastVisualUpdate = now

    local auraEnabled = getgenv().__deltaV3_auraOn
    local hrp         = Cache and Cache.RootPart

    if not auraEnabled or not hrp or not hrp.Parent then
        auraOuter.Transparency = 1
        auraInner.Transparency = 1
        return
    end

    local b         = getBall()
    local ballSpeed = (b and b.Parent and b.AssemblyLinearVelocity.Magnitude) or 45
    local vSize     = (math.max(ballSpeed, 45) * 0.22) + activationDistanceOffset

    auraOuter.CFrame = hrp.CFrame
    auraInner.CFrame = hrp.CFrame
    auraOuter.Size   = Vector3.new(vSize * 2, vSize * 2, vSize * 2)
    auraInner.Size   = Vector3.new((vSize - 0.4) * 2, (vSize - 0.4) * 2, (vSize - 0.4) * 2)

    local targetColor = clashSpamOn and CLASH_COLOR
                     or spamOn      and SPAM_COLOR
                     or AREA_COLOR

    auraOuter.Color        = auraOuter.Color:Lerp(targetColor, 0.3)
    auraOuter.Transparency = OUTER_TRANSPARENCY
    auraInner.Transparency = INNER_TRANSPARENCY
end)

-- ============================================================
-- SINGLE HEARTBEAT — parry + spam + clash tudo junto
-- ============================================================
local function bind(ch)
    setupCharacter(ch)

    local hrp         = ch:WaitForChild("HumanoidRootPart", 10)
    local lastBallPos = nil
    local ballResetAt = 0
    local vel         = Vector3.zero
    local lastBP      = nil
    local lastBT      = nil
    local lastFire    = 0
    local pingTimer   = 0

    local connection
    connection = RS.Heartbeat:Connect(function(dt)
        if not (ch and ch.Parent and hrp and hrp.Parent) then
            connection:Disconnect()
            return
        end

        local now          = tick()
        local autoParryOn  = getgenv().__deltaV3_autoParryOn
        local autoClashOn  = getgenv().__deltaV3_autoClashOn
        local spamInterval = getgenv().__deltaV3_spamInterval or Config.spamInterval

        -- Clash spam só ativo se autoClash ligado e clash confirmado
        clashSpamOn = (autoClashOn and ClashState.Active) and true or false

        -- ── SPAM (manual OU clash) ──
        if spamOn or clashSpamOn then
            local fired = 0
            while (now - lastSpamFire) >= spamInterval and fired < Config.spamCapPerFrame do
                sendParry()
                lastSpamFire = lastSpamFire + spamInterval
                fired        = fired + 1
            end
            -- Evita acúmulo infinito de débito
            if (now - lastSpamFire) > spamInterval * Config.spamCapPerFrame then
                lastSpamFire = now
            end
            return
        else
            lastSpamFire = now
        end

        -- ── AUTO PARRY ──
        if not autoParryOn then return end

        -- Ping atualizado a cada 2s
        pingTimer = pingTimer + dt
        if pingTimer >= 2 then
            pingTimer = 0
            task.spawn(updatePing)
        end

        -- Reset de processamento
        local resetInt = ClashState.Active and Config.processResetClash or Config.processResetNormal
        if ballProcessed and (now - lastProcessReset) >= resetInt then
            ballProcessed = false
        end

        -- Decay do clash
        if ClashState.Active and (now - ClashState.LastActivationTime) > Config.clashDecayTime then
            ClashState.Active = false
            clashSpamOn       = false
            if State.current == "clash" then setState("normal") end
        end

        local b = getBall()
        if not (b and b.Parent) then return end

        local bp = b.Position

        -- Detecta teleporte/reset da bola
        if lastBallPos then
            local jump = (bp - lastBallPos).Magnitude
            if jump > Config.ballResetThresh then
                ballProcessed    = true
                lastProcessReset = now
                ballResetAt      = now
                vel              = Vector3.zero
                lastBP, lastBT   = nil, nil
                lastBallPos      = bp
                return
            end
        end
        lastBallPos = bp

        if (now - ballResetAt) < Config.ballResetLockout then return end

        -- Velocidade da bola
        local av = b.AssemblyLinearVelocity
        if typeof(av) == "Vector3" and av.Magnitude > 0.1 then
            vel            = av
            lastBT, lastBP = now, bp
        elseif not lastBT then
            lastBT, lastBP = now, bp
        else
            local dtt = now - lastBT
            if dtt > 0 then
                local raw = (bp - lastBP) / dtt
                local a   = dt / (Config.velSmooth + dt)
                vel        = vel + (raw - vel) * a
                lastBT, lastBP = now, bp
            end
        end

        local hrpPos = hrp.Position

        -- Detecção de clash com velocidade da bola como argumento
        local currentTarget = WS:GetAttribute("GameBallTarget")
        if currentTarget then
            updateClashDetection(currentTarget, bp, vel, hrpPos)
        end

        local spd     = vel.Magnitude
        local baseRad = math_clamp(spd * Config.radiusWin + Config.radiusOff, Config.minRadius, Config.maxRadius) + Config.radiusPre
        local rad     = ClashState.Active and (baseRad * Config.clashRadMult) or baseRad
        local d       = (bp - hrpPos).Magnitude
        local app     = vel:Dot(hrpPos - bp) > 0
        local tgt     = tgtOn()
        local tImp    = spd > 1 and (d / spd) or 1e6
        local ping    = getPingCompensation()

        local cdFactor  = ClashState.Active and Config.clashCDFactor or Config.parryCDFactor
        local dynamicCD = math_clamp(tImp * cdFactor, Config.parryCDMin, Config.parryCDMax)

        local can = tgt and app
            and spd  > Config.minSpeed
            and d    <= rad
            and tImp <= (Config.maxImpactTime + ping)

        if can and not ballProcessed and (now - lastFire) >= dynamicCD then
            sendParry()
            lastFire         = now
            ballProcessed    = true
            lastProcessReset = now
            setState("normal")
        end
    end)

    getgenv().__na_aex_conn = connection

    ch.AncestryChanged:Connect(function(_, p)
        if not p then
            connection:Disconnect()
            setSpam(false)
            clashSpamOn            = false
            lastSpamFire           = 0
            ClashState.Active      = false
            ClashState.LastClashTime = 0
            lastBallPos            = nil
            auraOuter.Transparency = 1
            auraInner.Transparency = 1
        end
    end)
end

lp.CharacterAdded:Connect(bind)
if lp.Character then bind(lp.Character) end

-- ============================================================
-- CLEANUP GLOBAL
-- ============================================================
CoreGui.ChildRemoved:Connect(function(c)
    if c.Name == "DeltaV3Gui" then
        if auraConn then auraConn:Disconnect() end
        pcall(function() auraOuter:Destroy() end)
        pcall(function() auraInner:Destroy() end)
        getgenv().__na_aex = nil
        if getgenv().__na_aex_conn then
            getgenv().__na_aex_conn:Disconnect()
            getgenv().__na_aex_conn = nil
        end
    end
end)
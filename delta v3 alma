-- Blade Ball Auto Parry + Spam [v5.0]
-- 1 Heartbeat | Aura via BallSyncData

local tick       = tick
local math_clamp = math.clamp
local typeof     = typeof

-- cleanup de execução anterior
if getgenv().__na_aex_conn then
    getgenv().__na_aex_conn:Disconnect()
    getgenv().__na_aex_conn = nil
end
if getgenv().__na_aex then return end
getgenv().__na_aex = true

if game.GameId ~= 4538598064 then return end

-- services
local Plrs    = game:GetService("Players")
local RS      = game:GetService("RunService")
local RSrv    = game:GetService("ReplicatedStorage")
local WS      = workspace
local UIS     = game:GetService("UserInputService")
local Stats   = game:GetService("Stats")
local CoreGui = game:GetService("CoreGui")

-- config
local Config = {
    parryCDMin    = 0.05,
    parryCDMax    = 0.3,
    parryCDFactor = 0.5,
    clashCDFactor = 0.1,

    velSmooth     = 0.05,
    minRadius     = 9,
    maxRadius     = 90,
    radiusWin     = 0.32,
    radiusOff     = 6,
    radiusPre     = 10,
    minSpeed      = 5,
    maxImpactTime = 0.35,

    ballResetThresh  = 50,
    ballResetLockout = 0.6,

    processResetNormal = 0.3,
    processResetClash  = 0.05,

    clashRadMult = 1.5,

    spamInterval    = 0.00167,
    spamCapPerFrame = 10,

    pingSmooth     = 0.15,
    pingMultiplier = 1.1,
    pingOffset     = 0.02,
    pingMin        = 0.02,
    pingMax        = 0.25,

    clashHistorySize  = 8,
    clashTimeWindow   = 0.45,
    clashMinDist      = 35,
    clashCriticalDist = 12,
    clashDecayTime    = 1.2,
    clashMinHistory   = 4,
    clashCooldown     = 1.5,

    activationDistanceOffset = 7,
    auraUpdateRate           = 0.015,
}

-- getgenv: defaults e comunicação com o controle
if getgenv().__deltaV3_autoParryOn  == nil then getgenv().__deltaV3_autoParryOn  = true    end
if getgenv().__deltaV3_autoClashOn  == nil then getgenv().__deltaV3_autoClashOn  = true    end
if getgenv().__deltaV3_auraOn       == nil then getgenv().__deltaV3_auraOn       = true    end
if getgenv().__deltaV3_spamInterval == nil then getgenv().__deltaV3_spamInterval = 0.00167 end

-- network
local Net  = require(RSrv.TS.Network.Network).Network
local Def  = require(RSrv.TS.Abilities.DeflectAbility).DeflectAbility

local TS_Folder   = RSrv:WaitForChild("TS", 10)
local NetRemotes  = TS_Folder and TS_Folder:WaitForChild("GeneratedNetworkRemotes", 10)
local parryRemote = NetRemotes and NetRemotes:FindFirstChild("RE_4.6848415795802784e+76")

-- BallSyncData: velocidade real do servidor, usada pela aura
local ballSyncRemote = RSrv:WaitForChild("Remotes", 5)
ballSyncRemote = ballSyncRemote and ballSyncRemote:FindFirstChild("BallSyncData")

local touchTapEvent = RSrv:FindFirstChild("TouchTap")

local PNotif = RSrv:WaitForChild("PromptNotification")
task.spawn(function()
    PNotif:Fire("Auto Parry FINAL v5.0 ✅ | Aura Real | Clash Preciso", true)
end)

local spamOn      = false
local clashSpamOn = false

local originalIsAvailable
originalIsAvailable = hookfunction(Def.IsAvailable, function(self, ...)
    if spamOn or clashSpamOn then return true end
    return originalIsAvailable(self, ...)
end)

local oSend
oSend = hookfunction(Net.CSendEvent, function(self, router, evt, ...)
    if router == 46848415795802784000000000000000000000000000000000000000000000000000000000000 then
        return oSend(self, router, 29338138590583890000000000000000000000000000000000000000000000000000000000000, ...)
    end
    return oSend(self, router, evt, ...)
end)

local Cache = { Character = nil, RootPart = nil, Ball = nil }

local function getParryCFrame()
    return Cache.RootPart and Cache.RootPart.CFrame or CFrame.new()
end

local function getBallCFrame()
    return Cache.Ball and Cache.Ball.CFrame or getParryCFrame()
end

local function sendParry()
    -- método direto com CFrame real (Tek/Phantom)
    if parryRemote and Cache.RootPart then
        parryRemote:FireServer(2.933813859058389e+76, getParryCFrame(), getBallCFrame())
    end
    -- fallback via Net
    if Net then
        Net:CSendEvent(
            46848415795802784000000000000000000000000000000000000000000000000000000000000,
            6846744283873508500000000000000000000000000000000000000000000000000000000000
        )
    end
    if touchTapEvent then
        touchTapEvent:Fire()
    end
end

-- game info
local gi, br

do
    local ok, mod = pcall(function()
        return require(RSrv:WaitForChild("TS"):WaitForChild("GameInfo"))
    end)
    if ok and mod and mod.GameInfo then gi = mod.GameInfo end
end

do
    local ok, mod = pcall(function()
        return require(
            RSrv:WaitForChild("TS")
                :WaitForChild("BallReplicator")
                :WaitForChild("BallReplicator")
        )
    end)
    if ok and mod and mod.BallReplicator then br = mod.BallReplicator end
end

local lp = Plrs.LocalPlayer

-- cache de bola
local function trySetBall(obj)
    if obj.Name == "GameBall" then Cache.Ball = obj end
end

WS.ChildAdded:Connect(trySetBall)
WS.ChildRemoved:Connect(function(obj)
    if Cache.Ball == obj then Cache.Ball = nil end
end)

for _, v in ipairs(WS:GetChildren()) do
    if v.Name == "GameBall" then Cache.Ball = v; break end
end

local function setupCharacter(ch)
    if not ch then return end
    Cache.Character = ch
    Cache.RootPart  = ch:WaitForChild("HumanoidRootPart", 10)
end

lp.CharacterAdded:Connect(setupCharacter)
setupCharacter(lp.Character)

local function getBall()
    if Cache.Ball and Cache.Ball.Parent then return Cache.Ball end
    if gi and gi.BallModel and gi.BallModel.Parent then
        Cache.Ball = gi.BallModel
        return Cache.Ball
    end
    Cache.Ball = WS:FindFirstChild("GameBall", true)
    return Cache.Ball
end

local function tgtOn()
    local ch = lp.Character
    if ch and ch:FindFirstChild("Highlight") then return true end
    if WS:GetAttribute("GameBallTarget") == lp.UserId then return true end
    if br and br.syncData and br.syncData.HighlightTargetPlayerID == lp.UserId then return true end
    return false
end

-- ball sync: pega velocidade real do servidor pra aura bater certo
local BallSync = {
    RealPosition = Vector3.zero,
    Speed        = 0,
    TargetID     = -999,
}

if ballSyncRemote then
    ballSyncRemote.OnClientEvent:Connect(function(data)
        if typeof(data) ~= "table" then return end
        if data.RealPosition then
            BallSync.RealPosition = data.RealPosition
        end
        if typeof(data.Speed) == "number" then
            BallSync.Speed = data.Speed
        elseif type(data.Speed) == "table" and data.Speed.Magnitude then
            BallSync.Speed = data.Speed.Magnitude
        end
        if data.TargetPlayerID then
            BallSync.TargetID = data.TargetPlayerID
        end
    end)
end

-- ping
local smoothedPing = 0.05

local function updatePing()
    local ok, raw = pcall(function()
        return Stats.Network.ServerStatsItem["Data Ping"]:GetValue() / 1000
    end)
    if ok and type(raw) == "number" and raw > 0 then
        smoothedPing = smoothedPing * (1 - Config.pingSmooth) + raw * Config.pingSmooth
    end
end

local function getPingCompensation()
    return math_clamp(
        smoothedPing * Config.pingMultiplier + Config.pingOffset,
        Config.pingMin, Config.pingMax
    )
end

-- state machine
local State = { current = "normal", lastTransition = 0 }

local function setState(s)
    if State.current == s then return end
    State.current        = s
    State.lastTransition = tick()
end

-- reentrância
local ballProcessed    = false
local lastProcessReset = 0

-- clash: exige padrão alternado confirmado + cooldown entre ativações
-- corrige o bug do v3.2 original que ativava clash com qualquer bola perto
local ClashState = {
    Active             = false,
    LastActivationTime = 0,
    LastClashTime      = 0,
    CurrentOpponent    = nil,
}

local TargetHistory = {}
local lastTarget    = nil

local function updateClashDetection(newTargetID, ballPos, ballVel, hrpPos)
    if newTargetID == lastTarget then return end

    -- troca de alvo = bola mudou direção, libera parry imediatamente
    if lastTarget ~= nil then
        ballProcessed    = false
        lastProcessReset = 0
    end

    lastTarget = newTargetID

    if not Cache.RootPart then return end

    local dist = (hrpPos - ballPos).Magnitude
    local now  = tick()

    table.insert(TargetHistory, 1, { id = newTargetID, t = now })
    if #TargetHistory > Config.clashHistorySize then
        table.remove(TargetHistory)
    end

    if (now - ClashState.LastClashTime) < Config.clashCooldown then return end

    -- padrão alternado: eu → oponente → eu → oponente...
    if #TargetHistory >= Config.clashMinHistory then
        local timeGap = TargetHistory[1].t - TargetHistory[Config.clashMinHistory].t

        local isAlternating = true
        for i = 1, Config.clashMinHistory do
            local expectedMe = (i % 2 == 1)
            local isMe       = (TargetHistory[i].id == lp.UserId)
            if expectedMe ~= isMe then
                isAlternating = false
                break
            end
        end

        if isAlternating and timeGap < Config.clashTimeWindow and dist < Config.clashMinDist then
            ClashState.Active             = true
            ClashState.LastActivationTime = now
            ClashState.LastClashTime      = now
            ClashState.CurrentOpponent    = TargetHistory[2].id
            setState("clash")
        end
    end

    -- distância crítica: só ativa se bola vem em minha direção
    if newTargetID == lp.UserId
        and dist < Config.clashCriticalDist
        and ballVel ~= nil
        and ballVel:Dot(hrpPos - ballPos) > 0
    then
        ClashState.Active             = true
        ClashState.LastActivationTime = now
        ClashState.LastClashTime      = now
        setState("clash")
    end
end

-- spam
local lastSpamFire = 0
local toggleButton

local function updateGUI()
    if not toggleButton then return end
    toggleButton.Text             = spamOn and "SPAM ON" or "SPAM OFF"
    toggleButton.BackgroundColor3 = spamOn
        and Color3.fromRGB(50, 220, 50)
        or  Color3.fromRGB(220, 50, 50)
end

local function setSpam(v)
    if spamOn == v then return end
    spamOn       = v
    lastSpamFire = tick()
    setState(v and "spam" or "normal")
    updateGUI()
end

getgenv().__deltaV3_setSpam = function(v) setSpam(v) end

-- tecla gerenciada pelo controle via bindSpamKey

-- GUI de spam (começa escondida, o controle mostra)
task.spawn(function()
    local old = CoreGui:FindFirstChild("ParrySpamToggleGui")
    if old then old:Destroy() end

    local screenGui = Instance.new("ScreenGui")
    screenGui.Name           = "ParrySpamToggleGui"
    screenGui.ResetOnSpawn   = false
    screenGui.IgnoreGuiInset = true
    screenGui.Enabled        = false
    screenGui.Parent         = CoreGui

    local mainFrame = Instance.new("Frame")
    mainFrame.Size             = UDim2.new(0, 120, 0, 95)
    mainFrame.Position         = UDim2.new(1, -130, 0.5, -47)
    mainFrame.BackgroundColor3 = Color3.fromRGB(18, 18, 30)
    mainFrame.BorderSizePixel  = 0
    mainFrame.Parent           = screenGui
    Instance.new("UICorner", mainFrame).CornerRadius = UDim.new(0, 14)

    local stroke     = Instance.new("UIStroke")
    stroke.Color     = Color3.fromRGB(70, 90, 200)
    stroke.Thickness = 1.5
    stroke.Parent    = mainFrame

    local titleBar = Instance.new("Frame")
    titleBar.Size             = UDim2.new(1, 0, 0, 24)
    titleBar.BackgroundColor3 = Color3.fromRGB(30, 30, 55)
    titleBar.BorderSizePixel  = 0
    titleBar.Parent           = mainFrame
    Instance.new("UICorner", titleBar).CornerRadius = UDim.new(0, 14)

    local titleLabel = Instance.new("TextLabel")
    titleLabel.Size                   = UDim2.new(1, -6, 1, 0)
    titleLabel.Position               = UDim2.new(0, 6, 0, 0)
    titleLabel.BackgroundTransparency = 1
    titleLabel.Text                   = "FINAL v5.0 [1]"
    titleLabel.TextColor3             = Color3.fromRGB(180, 195, 255)
    titleLabel.TextScaled             = true
    titleLabel.Font                   = Enum.Font.GothamBold
    titleLabel.Parent                 = titleBar

    toggleButton = Instance.new("TextButton")
    toggleButton.Size             = UDim2.new(0.85, 0, 0, 52)
    toggleButton.Position         = UDim2.new(0.075, 0, 0, 30)
    toggleButton.BackgroundColor3 = Color3.fromRGB(220, 50, 50)
    toggleButton.BorderSizePixel  = 0
    toggleButton.Text             = "SPAM OFF"
    toggleButton.TextColor3       = Color3.fromRGB(255, 255, 255)
    toggleButton.TextScaled       = true
    toggleButton.Font             = Enum.Font.GothamBold
    toggleButton.Parent           = mainFrame
    Instance.new("UICorner", toggleButton).CornerRadius = UDim.new(0, 10)

    local dragging, dragStart, startPos = false, nil, nil

    local function updateDrag(input)
        if not dragStart or not startPos then return end
        local delta  = input.Position - dragStart
        local vpSize = WS.CurrentCamera.ViewportSize
        local fSize  = mainFrame.AbsoluteSize
        mainFrame.Position = UDim2.new(
            0, math_clamp(startPos.X.Offset + delta.X, 0, vpSize.X - fSize.X),
            0, math_clamp(startPos.Y.Offset + delta.Y, 0, vpSize.Y - fSize.Y)
        )
    end

    titleBar.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1
        or input.UserInputType == Enum.UserInputType.Touch then
            dragging  = true
            dragStart = input.Position
            startPos  = mainFrame.Position
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                end
            end)
        end
    end)

    titleBar.InputChanged:Connect(function(input)
        if dragging and (
            input.UserInputType == Enum.UserInputType.MouseMovement or
            input.UserInputType == Enum.UserInputType.Touch
        ) then updateDrag(input) end
    end)

    UIS.InputChanged:Connect(function(input)
        if dragging and input.UserInputType == Enum.UserInputType.Touch then
            updateDrag(input)
        end
    end)

    toggleButton.Activated:Connect(function() setSpam(not spamOn) end)
    updateGUI()
end)

-- aura visual (RenderStepped — só visual, correto separar do Heartbeat)
-- raio usa BallSync.Speed (real) pra bater com a zona de detecção real
local OUTER_TRANSPARENCY = 0.18
local INNER_TRANSPARENCY = 0.9
local AREA_COLOR         = Color3.fromRGB(255, 255, 255)
local SPAM_COLOR         = Color3.fromRGB(255, 50,  50)
local CLASH_COLOR        = Color3.fromRGB(255, 200, 50)

local function createAuraPart(name)
    local p = Instance.new("Part")
    p.Name         = name
    p.Shape        = Enum.PartType.Ball
    p.Material     = Enum.Material.ForceField
    p.Anchored     = true
    p.CanCollide   = false
    p.CastShadow   = false
    p.Transparency = 1
    p.Color        = AREA_COLOR
    p.Parent       = WS
    return p
end

local auraOuter = createAuraPart("DeltaAuraOuter")
local auraInner = createAuraPart("DeltaAuraInner")
local lastVisualUpdate = 0

local auraConn = RS.RenderStepped:Connect(function()
    local now = tick()
    if (now - lastVisualUpdate) < Config.auraUpdateRate then return end
    lastVisualUpdate = now

    local auraEnabled = getgenv().__deltaV3_auraOn
    local hrp         = Cache.RootPart

    if not auraEnabled or not hrp or not hrp.Parent then
        auraOuter.Transparency = 1
        auraInner.Transparency = 1
        return
    end

    local b         = getBall()
    local realSpeed = BallSync.Speed > 0 and BallSync.Speed
                   or (b and b.Parent and b.AssemblyLinearVelocity.Magnitude)
                   or 45

    -- mesma fórmula do auto parry: raio visual = raio de detecção real
    local baseRad = math_clamp(
        realSpeed * Config.radiusWin + Config.radiusOff,
        Config.minRadius, Config.maxRadius
    ) + Config.radiusPre + Config.activationDistanceOffset

    local rad = ClashState.Active and (baseRad * Config.clashRadMult) or baseRad
    local sz   = Vector3.new(rad * 2, rad * 2, rad * 2)
    local szIn = Vector3.new((rad - 0.5) * 2, (rad - 0.5) * 2, (rad - 0.5) * 2)

    auraOuter.CFrame = hrp.CFrame
    auraInner.CFrame = hrp.CFrame
    auraOuter.Size   = sz
    auraInner.Size   = szIn

    local targetColor = clashSpamOn and CLASH_COLOR
                     or spamOn      and SPAM_COLOR
                     or AREA_COLOR

    auraOuter.Color        = auraOuter.Color:Lerp(targetColor, 0.3)
    auraOuter.Transparency = OUTER_TRANSPARENCY
    auraInner.Transparency = INNER_TRANSPARENCY
end)

-- heartbeat principal: parry + spam + clash num único loop
local function bind(ch)
    setupCharacter(ch)

    local hrp         = ch:WaitForChild("HumanoidRootPart", 10)
    local lastBallPos = nil
    local ballResetAt = 0
    local vel         = Vector3.zero
    local lastBP      = nil
    local lastBT      = nil
    local lastFire    = 0
    local pingTimer   = 0

    local connection
    connection = RS.Heartbeat:Connect(function(dt)
        if not (ch and ch.Parent and hrp and hrp.Parent) then
            connection:Disconnect()
            return
        end

        local now          = tick()
        local autoParryOn  = getgenv().__deltaV3_autoParryOn
        local autoClashOn  = getgenv().__deltaV3_autoClashOn
        local spamInterval = getgenv().__deltaV3_spamInterval or Config.spamInterval

        clashSpamOn = (autoClashOn and ClashState.Active) and true or false

        -- spam (manual ou clash): prioridade máxima, não roda parry no mesmo frame
        if spamOn or clashSpamOn then
            local fired = 0
            while (now - lastSpamFire) >= spamInterval and fired < Config.spamCapPerFrame do
                sendParry()
                lastSpamFire = lastSpamFire + spamInterval
                fired        = fired + 1
            end
            if (now - lastSpamFire) > spamInterval * Config.spamCapPerFrame then
                lastSpamFire = now
            end
            return
        else
            lastSpamFire = now
        end

        if not autoParryOn then return end

        pingTimer = pingTimer + dt
        if pingTimer >= 2 then
            pingTimer = 0
            task.spawn(updatePing)
        end

        local resetInt = ClashState.Active and Config.processResetClash or Config.processResetNormal
        if ballProcessed and (now - lastProcessReset) >= resetInt then
            ballProcessed = false
        end

        if ClashState.Active and (now - ClashState.LastActivationTime) > Config.clashDecayTime then
            ClashState.Active = false
            clashSpamOn       = false
            if State.current == "clash" then setState("normal") end
        end

        local b = getBall()
        if not (b and b.Parent) then return end

        local bp = b.Position

        -- teleporte/reset da bola: bloqueia parry por ballResetLockout
        if lastBallPos then
            local jump = (bp - lastBallPos).Magnitude
            if jump > Config.ballResetThresh then
                ballProcessed    = true
                lastProcessReset = now
                ballResetAt      = now
                vel              = Vector3.zero
                lastBP, lastBT   = nil, nil
                lastBallPos      = bp
                return
            end
        end
        lastBallPos = bp

        if (now - ballResetAt) < Config.ballResetLockout then return end

        local av = b.AssemblyLinearVelocity
        if typeof(av) == "Vector3" and av.Magnitude > 0.1 then
            vel            = av
            lastBT, lastBP = now, bp
        elseif not lastBT then
            lastBT, lastBP = now, bp
        else
            local dtt = now - lastBT
            if dtt > 0 then
                local raw = (bp - lastBP) / dtt
                local a   = dt / (Config.velSmooth + dt)
                vel        = vel + (raw - vel) * a
                lastBT, lastBP = now, bp
            end
        end

        local hrpPos = hrp.Position

        local currentTarget = WS:GetAttribute("GameBallTarget")
        if currentTarget then
            updateClashDetection(currentTarget, bp, vel, hrpPos)
        end

        local spd     = vel.Magnitude
        local baseRad = math_clamp(
            spd * Config.radiusWin + Config.radiusOff,
            Config.minRadius, Config.maxRadius
        ) + Config.radiusPre
        local rad     = ClashState.Active and (baseRad * Config.clashRadMult) or baseRad
        local d       = (bp - hrpPos).Magnitude
        local app     = vel:Dot(hrpPos - bp) > 0
        local tgt     = tgtOn()
        local tImp    = spd > 1 and (d / spd) or 1e6
        local ping    = getPingCompensation()

        local cdFactor  = ClashState.Active and Config.clashCDFactor or Config.parryCDFactor
        local dynamicCD = math_clamp(tImp * cdFactor, Config.parryCDMin, Config.parryCDMax)

        local can = tgt and app
            and spd  > Config.minSpeed
            and d    <= rad
            and tImp <= (Config.maxImpactTime + ping)

        if can and not ballProcessed and (now - lastFire) >= dynamicCD then
            sendParry()
            lastFire         = now
            ballProcessed    = true
            lastProcessReset = now
            setState("normal")
        end
    end)

    getgenv().__na_aex_conn = connection

    ch.AncestryChanged:Connect(function(_, p)
        if not p then
            connection:Disconnect()
            setSpam(false)
            clashSpamOn              = false
            lastSpamFire             = 0
            ClashState.Active        = false
            ClashState.LastClashTime = 0
            lastBallPos              = nil
            auraOuter.Transparency   = 1
            auraInner.Transparency   = 1
            updateGUI()
        end
    end)
end

lp.CharacterAdded:Connect(bind)
if lp.Character then bind(lp.Character) end

-- cleanup ao remover a GUI do controle
CoreGui.ChildRemoved:Connect(function(c)
    if c.Name == "DeltaV3Gui" then
        if auraConn then auraConn:Disconnect() end
        pcall(function() auraOuter:Destroy() end)
        pcall(function() auraInner:Destroy() end)
        getgenv().__na_aex = nil
        if getgenv().__na_aex_conn then
            getgenv().__na_aex_conn:Disconnect()
            getgenv().__na_aex_conn = nil
        end
    end
end)